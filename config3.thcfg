encoding  utf-8




###### Select this as line type “u” with “-subtype <new line>” in its options
######
# Existing user points / nouvelles définitions de points :
#  - nid/nest (u:nest)
#  - gradient -->  geologic dip
#  - danger (u:danger)
#  - chauves-souris/bats (u:bats)
#  - stalactite boss (u:boss)
#  - Shell/coquille fossile (u:shell)
#  - Masonry/maçonnerie (u:masonry)
#  - Ex voto/Signature (u:ex_voto)
#  - Human bones/Ossements humains (u:human_bones)
#  - Walking Caver/Spéléo qui marche (u:man_w)
#   - Climbing caver/Spéléo qui grimpe (u:man_c)
#  - Plan view symbol/symbole de vue en plan (u:symbol_plan)
#  - extended view symbol/symbole de vue en coupe développée (u:symbol_extend)
#  - point u:anchor_natural" "amarrage naturel"
#  - point u:anchor_artificial" "amarrage artificiel"

# Existing user lines:
#  - strate/strata (u:strata; option -clip off)
#  - coupole (u:coupole; option -clip off)
#  - faille/fault (u:fault; option -clip off)
#  - doline (u:doline; option -clip off)
#  - chauves-souris/bats (u:bats)
#  - rail (u:rail)
#  - plan walk/ (u:planwalk)
#  - handrail/rambarde (u:handrail)
#  - Surface (u:surf)
#  - Dive line/fil d'Ariane (u:ariane)
#  - Deviation (u:deviation)  

# Existing user areas:
#   - boue/mud (u:boue)
#  - guano (u:guano)
#  - chauves-souris/bats (u:bats)
#  - tronc/tree-trunk (u:tronc)
#  - feuilles/tree-leaves (u:feuilles)
#  - Tunnel initiation/Départ de galerie (u:galerie)


####################################
############## MANUAL ##############
####################################

#####Point anchor 
# By using the “-attr type” option, you can control which type of anchor it will show:
# “-attr type auto” (default) shows a P-hanger (like “p”) in plan view, and a filled circle in elevation view.
# “-attr type p” shows a P-hanger in either plan or elevation view - the control point is at the place where a P-hanger meets the wall, not where the rope meets the hanger.
# “-attr type ropedp” the same as “p” but the control point is at the place where the hanger meets the rope - this can be more useful for showing it with ropes attached.
# “-attr type fixed” shows a filled circle in either plan or elevation view.
# “-attr type natural” shows an empty circle in either plan or elevation view, a common symbol for “natural belay” - note that this circle is filled with the scrap background colour in order to obscure any ropes, though this may look odd if placed outside the cave.



# change les descriptions des symboles pour la légende

text en "point anchor" "hanger/bolt/spit/belay, fixed, natural"
text fr "point anchor" "broche, spit/pulse, AF"

text fr "point u:anchor_artificial" "ancrage artificiel"

text fr "point u:anchor_natural" "amarrage naturel"

text en "point u:deviation" "deviation"
text fr "point u:deviation" "déviation"

text en "line u:deviation" "deviation"
text fr "line u:deviation" "déviation"

text en "line u:rope" "rope" 
text fr "line u:rope" "corde" 

text en "line u:fault" "fault" 
text fr "line u:fault" "faille" 

text en "line u:strata" "strata" 
text fr "line u:strata" "strate" 

text en "line u:doline" "doline" 
text fr "line u:doline" "doline" 

text en "point u:bats" "bat(s)"
text fr "point u:bats" "chauve-souris"

text en "line u:bats" "bat path"
text fr "line u:bats" "passage de chauve-souris"

text en "area u:bats" "lot of bats"
text fr "area u:bats" "beaucoup de chauve-souris"

text fr "line u:galerie" ""
text fr "area u:galerie" "départ de galerie"
text en "area u:galerie" "tunnel departure"

text en "point u:guacharos" "guacharos"
text fr "point u:guacharos" "guacharos"

#text fr "point danger" "danger !"
#text en "point danger" "danger !"

#text en "point masonry" "masonry"
#text fr "point masonry" "maçonnerie/murs"

#text en "point ex-voto" "ex voto"
#text fr "point ex-voto" "ex voto/signature"

#text en "point human-bones" "human bones"
#text fr "point human-bones" "ossements humains"

#text en "point u:boss" "stalagmite boss"
#text fr "point u:boss" "stalagmite boss"

text fr "area u:guano" "guano"
text en "area u:guano" "guano"

text fr "area u:boue" "lac de boue"
text en "area u:boue" "mud lake"

text fr "area u:tronc" "tronc d'arbre"
text en "area u:tronc" "Tree trunk"

text fr "area u:feuilles" "feuilles/feuillage"
text en "area u:feuilles" "tree leaves"

text en "line u:sentier" "trail"
text fr "line u:sentier" "sentier"

text en "point u:shell" "shell"
text fr "point u:shell" "fossile"

text fr "point traverse" "vire"
text fr "point ice-stalagmite" "stalagmite de glace"

text en "point u:man_w" "caver (walking)"
text fr "point u:man_w" "spéléo (marchant)"

text en "point u:man_c" "caver (climbing)"
text fr "point u:man_c" "spéléo (grimpant)"

text en "point u:symbol_plan" ""
text fr "point u:symbol_plan" ""

text en "point u:symbol_extend" ""
text fr "point u:symbol_extend" ""

text en "line border:visible" ""
text fr "line border:visible" ""

text fr "line wall:sand" ""

text fr "line wall:pit" ""

#text fr "line wall:rock" "paroi"  # Ne fonctionne pas

#text fr "point waterflow:permanent" "écoulement"  # Ne fonctionne pas











### Layouts Languages/langues
# Différents layouts pour définir les langues (en, fr)
#     Dans votre thconfig, appelez le layout langue-XX où XX est en ou fr 
#     Vous devez ajouter l'un de ces layouts si vous voulez utiliser les layouts headerl ou header_coupe
#     qui redéfinissent la présentation et les informations du cartouche (header).
#     Si vous voulez ajouter un de ces champs club, syntesys, web page, expedition, guide, 
#        rajouter la ligne suivante dans le bloc code tex-map/endcode  de votre layout dans votre thconfig
#        (voir les exemples)
#       \newtoks\YYYY \YYYY={Valeur de votre varialbe}
#        où YYYY = club, synth, wpage, expe or guide
#

layout langue-fr
  # Définit la langue française
  language fr
  
  code tex-map
    % Definition of variables for the tuned headers :
    \newtoks\thversiontitleB \thversiontitleB={Therion }

    \newtoks\thversiontitleA \thversiontitleA={Compilation }
    \newtoks\datetitle \datetitle={le }
    \newtoks\thproj \thproj={Projection }
    \newtoks\thclub \thclub={Club(s) }
    \newtoks\thsynth \thsynth={Synthèse }
    \newtoks\thwpage \thwpage={Page internet }
    \newtoks\thexpe \thexpe={Expedition }
    \newtoks\thguide \thguide={Guide(s) }
    \newtoks\thdatat \thdatat={Données topographiques }
    \newtoks\depthrangetitle \depthrangetitle={Depth range from }
    \newtoks\ththanksto \ththanksto{Nos remerciements }
    \newtoks\thcoords \thcoords{Coordonnées GPS (WGS84) }
    \newtoks\explolengthtitle \explolengthtitle{Longueur explorée }
    \newtoks\explodepthtitle \explodepthtitle{\thinspace{}---\thinspace{}\thinspace{}\thinspace{}\thinspace{}Profondeur explorée }

    # Initiate variables
    \newtoks\club \club={}
    \newtoks\synth \synth={}
    \newtoks\wpage \wpage={}
    \newtoks\expe \expe={}
    \newtoks\guide \guide={}
    \newtoks\datat \datat={}
    \newtoks\thanksto \thanksto={}
    \newtoks\ECoordinates \ECoordinates={}
    
  endcode
endlayout


layout header

### Pour définir une nouvelle flèche du nord
  code metapost
    def s_northarrow (expr rot) =
      begingroup
        interim defaultscale:=0.5; % scale your north arrow here ; 0.5 is the best value for atlas
        T:=identity scaled defaultscale rotated -rot;
        interim linecap:=squared;
        interim linejoin:=rounded;
        thfill (-.5cm,-.1cm)--(0,2.5cm)--(.5cm,-.1cm)--cycle;
        pickup pencircle scaled (0.08cm * defaultscale);
        thdraw (0,0)--(0,-2.5cm);
        pickup pencircle scaled (0.16cm * defaultscale);
        p:=(0.4cm,0.6cm);
        thdraw ((p--(p yscaled -1)--(p xscaled -1)--(p scaled -1)) shifted (0,-1.0cm));
        label.rt(thTEX("mg") scaled 1.6, (.6cm,-1.6cm)) transformed T;
      endgroup;
    enddef;
  endcode


### Change Scale bar type
  code metapost
    def s_scalebar (expr l, units, txt) =
      begingroup
        interim warningcheck:=0;
        tmpl:=l / Scale * cm * units / 2;
        tmpx:=l / Scale * cm * units / 5;
        tmph:=3.5bp; % bar height
      endgroup;
      pickup PenC;
      draw (-tmpl,0)--(tmpl,0)--(tmpl,-tmph)--(-tmpl,-tmph)--cycle;
      p:=(0,0)--(tmpx,0)--(tmpx,-tmph)--(0,-tmph)--cycle;
      for i:=-2.5 step 2 until 2:
        fill p shifted (i * tmpx,0);
      endfor;
      begingroup
        interim labeloffset:=3.5bp;
        for i:=0 step (l/5) until (l-1):
          tmpx:=tmpl * (i * 2 / l - 1);
          label.bot(thTEX(decimal (i)),(tmpx,-tmph));
        endfor;
        label.bot(thTEX(decimal (l) & "\thinspace" & txt),(tmpl,-tmph));
        % Pour écrire l'échelle "1:scale" au dessus de la barre décommenter la ligne suivante :
        label.top(thTEX("Echelle 1 : " & decimal (Scale*100)),(0,0));
      endgroup;
    enddef;
  endcode



### Utiliser la fonction vskip pour espacer les éléments du header
### eg: \vskip6mm
### Language is latex
# Ceci ne touche que les maps (plans)

code tex-map
    \legendcontent={
      \hsize=\legendwidth
      \color[0 0 0]\the\legendtextcolor
      %\parskip=0bp
      %\everypar{\hangindent=0em\hangafter=0/}

      
      %print northarrow
      \ifnortharrow\vbox to 25pt{\line{\hfil\northarrow}\vss}
      

      \fi
      %print cave map name
      \edef\tmp{\the\cavename} \ifx\tmp\empty \else
        {\the\legendtextheadersize\the\cavename}
      \vskip9mm %Distance between title and scalebar
      \fi
      %print scalebar
      \ifscalebar\scalebar
      \vskip6mm
      \fi
      %print cavelength and depth
      \edef\tmp{\the\cavelength} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\cavelengthtitle: \ss\the\cavelength\par}
      \fi
      \edef\tmp{\the\cavedepth} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\cavedepthtitle: \ss\the\cavedepth\par}
      \fi
       %print comment
      \edef\tmp{\the\comment} \ifx\tmp\empty \else
        {\the\legendtextsize\the\comment}
      \vskip-1mm
      \fi
      ## %      altitude
      #\edef\tmp{\the\cavemaxz} \ifx\tmp\empty \else
      #  {\the\legendtextsize\si\the\depthrangetitle \ss\the\cavemaxz m to}
      #\fi
      #\edef\tmp{\the\caveminz} \ifx\tmp\empty \else
      #  {\the\legendtextsize\ss\the\caveminz m \par} %above mean sea level
      #\fi
      %print explorers names
      \edef\tmp{\the\exploteam} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\explotitle: \ss\the\exploteam\quad\si\the\explodate\par}
      \fi
      %print surveyors names
      \edef\tmp{\the\topoteam} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\topotitle: \ss\the\topoteam\quad\si\the\topodate\par}
     \vskip3mm
      \fi
      %%print the guides
      \edef\tmp{\the\guide} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\thguide: \ss\the\guide\par}
      \fi
      %print cartographers names
      \edef\tmp{\the\cartoteam} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\cartotitle: \ss\the\cartoteam\quad\si\the\cartodate\par}
      \fi
      %print synthesys name !!!  !!! with newtoks\synth \synth={Synth Name} in the thconfig
      \edef\tmp{\the\synth} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\thsynth: \ss\the\synth\par}
      \fi
      %print the club
      \edef\tmp{\the\club} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\thclub: \ss\the\club\par}
      \fi
      %%print the expedition
      \edef\tmp{\the\expe} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\thexpe: \ss\the\expe\par}
      \fi
      %%print the web page
      \edef\tmp{\the\wpage} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\thwpage: \ss\the\wpage\par}
      \fi
      # % start bruces addition (compilation version and date modified to use built-in 5.3.15 variables)
      \edef\tmp{\the\thversion} \ifx\tmp\empty \else  %only write version and date if version is not emplty
        {\the\legendtextsize\si\the\thversiontitleA: \ss\the\thversiontitleB \ss\the\thversion}
      % \fi
      % \edef\tmp{\the\currentdate} \ifx\tmp\empty \else
        {\the\legendtextsize\si\the\datetitle \ss\the\currentdate\par}
      \fi
      # % end bruces addition
      %print copyrights
      \edef\tmp{\the\copyrights} \ifx\tmp\empty \else
        {\the\legendtextsize\ss\the\copyrights\par}
      \fi
      \bigskip
      \edef\tmp{\the\thanksto} \ifx\tmp\empty \else
          {\the\legendtextsize\si\the\ththanksto: \ss\the\thanksto\par}
          %\def\ththankstotitle{Nos remerciements : }
          %{\everypar{\hangindent=7.2em\hangafter=1}
          %\size[\thsizem]\si\ththankstotitle \ss\ththanksto\par}
      \fi
      \vskip-9mm
      %print legend
      \formattedlegend
    }

  endcode
endlayout




layout layoutcontinuation
# Si vous voulez écrire sur la carte le texte qui est donnée dans chaque définition 
#     de point d'interrogation de continuation

  code metapost
    def p_continuation(expr pos,theta,sc,al) =
      % draw default continuation symbol
      p_continuation_UIS(pos,theta,sc,al);
      % if text attribute is set
      if known(ATTR__text) and picture(ATTR__text):
        % set labeling color to light orange
        push_label_fill_color(1.0, 0.9, 0.8);
        % draw filled label with text next to ?
        p_label.urt(ATTR__text,(.5u,-.25u) transformed T,0.0,8);
        % restore original labeling color
        pop_label_fill_color;
      fi;
    enddef;
  endcode
  
endlayout 





layout drawingconfig
#Layout pour dessiner les plans et les coupes développées.
  

  #Auteur du pdf
  doc-author "Martin Kern"

  # Choix des symbols: UIS, ASF (Australie) CCNP (Etats Unis),SKB (tchecoslovakia)
  #symbol-set UIS        


  ### Choix des types de symbols
    symbol-assign point station:temporary SKBB
    symbol-assign point pillar AUT
  symbol-assign point anchor MY

        
    ### Choix des couleurs de symbols
  symbol-color point water-flow [17 46 100]
  symbol-color point water-flow:intermittent [17 46 100]
  symbol-color point water-flow:paleo [17 46 100]
 # symbol-color point water-drip [17 46 100]
  symbol-color point water [17 46 100]
  symbol-color line water-flow [17 46 100]
  symbol-color line water-flow:conjectural [17 46 100]
  symbol-color line water-flow:intermittent [17 46 100]
  symbol-color point ice [0 0 100]
  symbol-color line wall:ice [0 0 100]
  symbol-color point ice-pillar [0 0 100]
  symbol-color point ice-stalagmite [0 0 100]
  symbol-color point ice-stalactite [0 0 100]
  symbol-color area ice [0 0 100]
  symbol-color point snow [0 0 100]
  symbol-color area snow [0 0 100]
  symbol-color point spring [17 46 100]
  symbol-color point root [52 33 6]
  symbol-color point vegetable-debris [13 47 6]
  #symbol-color point seed-germination [13 47 6]
  symbol-color point altitude [100 50 0]
  symbol-color point station [54 7 60]
  symbol-color line flowstone [100 60 20]
  symbol-color line wall:flowstone [100 60 20]
  symbol-color point flowstone [100 60 20]
  symbol-color area flowstone [100 60 20]
  symbol-color area moonmilk [100 60 20]  # Change the color ?
  symbol-color point moonmilk [100 60 20]  # Change the color ?
  symbol-color line wall:moonmilk [100 60 20]  # Change the color ?
 # symbol-color point curtains [100 60 20]
  #symbol-color point curtain [100 60 20]
  #symbol-color point disc-pillar [100 60 20]
  #symbol-color point disc-stalactite [100 60 20]
  #symbol-color point disc-stalagmite [100 60 20]
  #symbol-color point disc-pillars [100 60 20]
  #symbol-color point disc-stalactites [100 60 20]
  #symbol-color point disc-stalagmites [100 60 20]
  #symbol-color point disk [100 60 20]
  #symbol-color point wall-calcite [100 60 20]
  #symbol-color point pillar [100 60 20]
  #symbol-color point pillar-with-curtains [100 60 20]
  #symbol-color point pillars-with-curtains [100 60 20]
  symbol-color point stalactite [100 60 20]
  symbol-color point stalagmite [100 60 20]
#  symbol-color point stalactite-stalagmite [100 60 20]
  #symbol-color point stalactites-stalagmites [100 60 20]
  #symbol-color point flowstone-choke [100 60 20]
  #symbol-color line rimstone-dam [100 60 20]
  #symbol-color line rimstone-pool [100 60 20]
  #symbol-color point rimstone-dam [100 60 20]
  #symbol-color area stalactite [100 60 20]
  #symbol-color area stalactite-stalagmite [100 60 20]
  #symbol-color area stalagmite [100 60 20]
  #symbol-color area pillar [100 60 20]
  #symbol-color area pillar-with-curtains [100 60 20]
  #symbol-color area mudcrack [52 33 6]  # Color to verify ; Maybe to darken
  symbol-color area clay [52 33 6]  # Color to verify
  symbol-color line wall:clay [52 33 6]  # Color to verify
  #symbol-color point volcano [52 33 6]  # Color to verify
 # symbol-color point mud [52 33 6]  # Color to verify
  #symbol-color point mudcrack [52 33 6]  # Color to verify
  symbol-color point clay [52 33 6]  # Color to verify
  #symbol-color point clay-tree [52 33 6]  # Color to verify
  #symbol-color point clay-choke [52 33 6]  # Color to verify
  symbol-color point wall-altitude [78 8 52]  # rouge-violet 199, 21, 133 --> normal
  #symbol-color point wall-altitude [0 0 100]  # Bleu 0, 0, 255 --> For sumps/siphons
  symbol-color line rope [58 44 25]     #


  ####### Metapost-changes ############
  code metapost

    # Modifier la ligne wall_pit par la ligne pit mais avec le trait ext épais comme celui des walls
    def l_wall_pit (expr P) =
    T:=identity;
    cas := 0;
    dlzka := arclength P;
    mojkrok:=adjust_step(dlzka, 0.25u);
    pickup PenD;
    forever:
      t := arctime cas of P;
      mark_ (P,t,0.2u);
      cas := cas + mojkrok;
      exitif cas > dlzka + (mojkrok / 3); % for rounding errors
    endfor;
    pickup PenA; % C'est ça qui a été modifié ; origin = "pickup PenC;"
    thdraw P;
    enddef;



    # Changer la ligne pointillée du symbole line wall:presumed
    def l_wall_presumed (expr P) = 
      T:=identity;
      pickup PenA;
      # Old definition
      #thdraw P dashed evenly scaled (2*optical_zoom);
      # New definition
      thdraw P dashed evenly scaled (.1u);
    enddef;
    
    # Changer la ligne pointillée du symbole line chemney (cheminée)
    def l_chimney (expr P) = 
      T:=identity;
      pickup PenC;
      %thdraw P dashed evenly scaled optical_zoom;
      thdraw P dashed evenly scaled (.05u);
    enddef;

    # Pour modifier la taille des blocs dans l'aire blocks
    def a_blocks (expr p) =
      T:=identity;
      pickup PenC;
      path q, qq; q = bbox p;
      picture tmp_pic;
      uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart     llcorner q)/100);
      tmp_pic := image(
      for i = xpart llcorner q step 1.0uu until xpart urcorner q:
        for j = ypart llcorner q step 1.0uu until ypart urcorner q:
          qq := punked (((-.3uu,-.3uu)--(.3uu,-.3uu)--(.3uu,.3uu)--(-.3uu,.3uu)--cycle)
          randomized (uu/2))
            rotated uniformdeviate(360)
            shifted ((i,j) randomized 1.0uu);
          if xpart (p intersectiontimes qq) < 0:
            thclean qq;
            thdraw qq;
          fi;
        endfor;
      endfor;
      );
      clip tmp_pic to p;
      draw tmp_pic;
    enddef;

     # To change sand aspects
     # Pour modifier les aspects du sable dans l'aire associée
     def a_sands (expr p) =
      T:=identity;
      pickup PenC;
      path q; q = bbox p;
      picture tmp_pic;
      tmp_pic := image(
      for i = xpart llcorner q step 0.1u until xpart urcorner q:
        for j = ypart llcorner q step 0.1u until ypart urcorner q:
          draw origin shifted ((i,j) randomized 0.1u) withpen PenC;
        endfor;
      endfor;
      );
      #clip tmp_pic to p;
      draw tmp_pic;
    enddef;

     # To change pebbles aspects
     # Pour modifier l'aspects de l'aire pebbles (galets)
     def a_pebbles_SKBB (expr p) =
      T:=identity;
      pickup PenC;
      path q, qq; q = bbox p;
      picture tmp_pic;
      tmp_pic := image(
      for i = xpart llcorner q step .1u until xpart urcorner q:
        for j = ypart llcorner q step .5u until ypart urcorner q:
          qq := (superellipse((.07u,0),(0,.03u), (-.07u,0),(0,.-.03u),.75))
          %randomized (u/25)
          rotated uniformdeviate(360)
          shifted ((i,j) randomized 0.27u);
          if xpart (p intersectiontimes qq) < 0:
            thdraw qq;
          fi;
        endfor;
      endfor;
      );
      clip tmp_pic to p;
      draw tmp_pic;
    enddef;

    # To change slopes aspects
    # Pour modifier la ligne aspects
    def l_slope (expr P,S)(text Q) = 
      %show Q;
      T:=identity;
      numeric dirs[];
      numeric lengths[];
      for i=Q:
        dirs[redpart i]:=greenpart i;
        lengths[redpart i]:=bluepart i;
      endfor;  
      li:=length(P); % last
      alw_perpendicular:=true;
      for i=0 upto li:
        if unknown dirs[i]: dirs[i]:=-1; 
        else: 
          if dirs[i]>-1:
            dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360;
            alw_perpendicular:=false;
          fi;
        fi;
        if unknown lengths[i]: lengths[i]:=-1; fi;
      endfor;
      %for i=0 upto li: show dirs[i]; endfor;
      ni:=0; % next
      pi:=0; % previous
      for i=0 upto li:
        d:=dirs[i];
        if d=-1:
          if (i=0) or (i=li):
            dirs[i] := angle(thdir(P,i) rotated 90) mod 360;
            pi:=i;
          else:
            if ni<=i:
              for j=i upto li:
                ni:=j;
                exitif dirs[j]>-1;
              endfor;
            fi;
            w:=arclength(subpath(pi,i) of P) / 
            arclength(subpath(pi,ni) of P);
            dirs[i]:=w[dirs[pi],dirs[ni]];
            %if (dirs[i]-angle(thdir(P,i))) mod 360>180:
            %dirs[i]:=w[dirs[ni],dirs[pi]];
            %message("*******");
            %fi;
          fi;
        else:
          pi:=i;
        fi;
      endfor;
      %for i=0 upto li: show dirs[i]; endfor;
      ni:=0; % next
      pi:=0; % previous
      for i=0 upto li:
        l:=lengths[i];
        if l=-1:
          if (i=0) or (i=li):
            lengths[i] := 1cm; % should never happen!
            thwarning("slope width at the end point not specified");
            pi:=i;
          else:
            if ni<=i:
              for j=i+1 upto li:
                ni:=j;
                exitif lengths[j]>-1;
              endfor;  
            fi;
            w:=arclength(subpath(pi,i) of P) /   
            arclength(subpath(pi,ni) of P);
            lengths[i]:=w[lengths[pi],lengths[ni]];
            pi:=i;
          fi;
        else:
          pi:=i;
        fi;
      endfor;
      %for i=0 upto li: show lengths[i]; endfor;
      T:=identity;
      boolean par;
      cas := 0.3u;
      krok := 0.7u;
      dlzka := (arclength P);
      if dlzka>3u: dlzka:=dlzka-0.6u fi;
      mojkrok:=adjust_step(dlzka,1.4u) / 5;
      pickup PenD;
      par := false;
      forever:
        t := arctime cas of P;
        if t mod 1>0:  % not a key point
          w := (arclength(subpath(floor t,t) of P) / 
          arclength(subpath(floor t,ceiling t) of P));
          if alw_perpendicular:
            a := 90;
          else:
            a := w[dirs[floor t],dirs[ceiling t]];
          fi;
          l := w[lengths[floor t],lengths[ceiling t]];
        else:
          if alw_perpendicular:
            a := 90;
          else:
            a:= dirs[t];
          fi; 
          l:=lengths[t];
        fi;    
        a := a + angle(thdir(P,t));    
        thdraw (point t of P) -- 
        ((point t of P) + if par: 0.333 * fi l * unitvector(dir(a)));
        cas := cas + mojkrok;
        par := not par;
        exitif cas > dlzka + .3u + (krok / 3);  % for rounding errors
      endfor;
      if S = 1: pickup PenC; draw P fi;
        %pickup pencircle scaled 3pt;
        %for i=0 upto li: draw point i of P; endfor;
    enddef; 

### To change color of Mud area
    def a_u_boue (expr p) =
      T:=identity;
      #thfill p withcolor (0.22, 0.22, 0.95);
      #126, 51, 0
      thfill p withcolor (0.49, 0.20, 0.00);
    enddef;

### To change color of Sump
    def a_sump (expr p) =
      T:=identity;
      #thfill p withcolor (0.22, 0.22, 0.95);
      thfill p withcolor (0.06, 0.20, 0.65);
    enddef;

    # To change color of guano
    # Pour modifier la couleur de l'aire guano
    def a_u_guano (expr p) =
      T:=identity;
      thfill p withcolor (0.53, 0.26, 0.11);
    enddef;
    
    # To change color of a tree-trunk
    #     I advise to use a line "border" to delimit the area
    #    If used with tree-leaves, add the option -place top
    # Pour modifier la couleur de l'aire tronc
    #    Je suggère d'utiliser une ligne "border/bord" pour délimiter l'aire
    #    Si utilisé conjointement avec l'aire feuilles d'arbres, utiliser l'option -place top
    def a_u_tronc (expr p) =
      T:=identity;
      thfill p withcolor (0.62, 0.24, 0.05);
    enddef;

    # To change color of a tree-leaves
    # Pour modifier la couleur de l'aire feuilles d'arbre/feuillage
    def a_u_feuilles (expr p) =
      T:=identity;
      thfill p withcolor (0.0, 1.0, 0.0);
    enddef;

    # To change color of Water area
    # Pour modifier la couleur de l'aire eau
    def a_water (expr p) =
      T:=identity;
      #thfill p withcolor (0.60, 0.8, 1);
      thfill p withcolor (0.17, 0.46, 1);
    enddef;

    def a_ice (expr p) =
        T:=identity;
        thfill p withcolor (0.7, 0.7, 0.9);
    enddef;

    # def p_ice_UIS (expr pos,theta,sc,al)=
    #   U:=(.4u,.35u);
    #   T:=identity aligned al rotated theta scaled sc shifted pos;
    #   pickup PenC;
    #   p := (0,.05u)--(0,.35u);
    #   thdraw p;
    #   thdraw p shifted (-.5u,-.1u);
    #   thdraw p shifted (.25u,-.3u);
    #   p := (-0.3u,.2u)--(0.15u,.2u);
    #   thdraw p;
    #   thdraw p shifted (-.25u,-.3u);
    #   thdraw p shifted (.25u,-.3u);
      
    # enddef;

    # For point height with P or C prefixe
    #     use “point 0 0 height -value [+10 m]”
    #     or “point 0 0 height -value [-85 m]”
    #     in your data to get E10 or P85
    # Pour obtenir un point de hauteur de passage avec P ou C comme préfixe
    #     utiliser “point 0 0 height -value [+10 m]”
    #     ou “point 0 0 height -value [-85 m]”
    #     dans les données vous donner E10 ou P85 respectivement
    verbatimtex \def\thheightpos{E}\def\thheightneg{P} etex


    # # Change the altitude definition for the wall-line label (add units)
    # #    To modify the color, you need to modify the triplets after the 3 withcolor command.
    # #    BE CAREFUL ! Sometimes, it generates mpost errors when using point wall:altitude.
    # #    If you get this kind of error, comment the whole p_wallaltitude definition.
    # # Changer la définition de l'altitude pour le label de la ligne mur (ajout de l'unité)
    # #    Pour modifier la couleur, modifier le triplet (RGB) après les 3 commandes withcolor.
    # #    ATTENTION ! Parfois, cette redéfinition génère des erreurs métapost.
    # #    Si c'est le cas, commenter toute la redéfinition du point p_wallaltitude.
    
    # def p_wallaltitude (expr pprev,pos,pnext,txt) =
    #   rot:=angle(unitvector(pnext-pos)+unitvector(pos-pprev)) - 90;
    #   pickup PenD;
    #   pair zz;
    #   %zz:=(pos + 3*unitvector(dir rot));
    #   zz:=(pos + (u/4)*unitvector(dir rot));
    #   %draw (pos)--zz withcolor (0.78, 0.08, 0.52); % tic in black
    #   draw (pos)--zz withcolor (0.78, 0.08, 0.52); % tic in color
    #   % add the unit (here, meters as m)
    #   txtm:=image(
    #       %draw txt; % altitude in black
    #       draw txt withcolor (0.78, 0.08, 0.52); % altitude in color
    #       %interim labeloffset:=0;
    #       %label.urt(btex \thaltitude { m} etex, lrcorner txt); % unit in black
    #       label.urt(btex \thaltitude { m} etex, lrcorner txt) withcolor (0.78, 0.08, 0.52); % unit in color
    #     );
    #   begingroup 
    #     %    interim labeloffset:=2pt;
    #     interim labeloffset:=(u/12);
    #     if horiz_labels:
    #       rot:=rot mod 360;
    #       if rot<=22.5: lab:=thelabel.rt(txtm, zz);
    #       elseif rot<=67.5: lab:=thelabel.urt(txtm, zz);
    #       elseif rot<=112.5: lab:=thelabel.top(txtm, zz);
    #       elseif rot<=157.5: lab:=thelabel.ulft(txtm, zz);
    #       elseif rot<=202.5: lab:=thelabel.lft(txtm, zz);
    #       elseif rot<=247.5: lab:=thelabel.llft(txtm, zz);
    #       elseif rot<=292.5: lab:=thelabel.bot(txtm, zz);
    #       elseif rot<=337.5: lab:=thelabel.lrt(txtm, zz);
    #       else: lab:=thelabel.rt(txtm, zz);
    #       fi;
    #     else:
    #       if (abs rot>90) and (abs rot <=270):
    #         rot:=rot-180;
    #         lab:=thelabel.lft(txtm, pos);
    #       else:
    #         lab:=thelabel.rt(txtm, pos);
    #         fi;
    #     fi;
    #     process_label(pos, if horiz_labels: 0 else: rot fi);    
    #   endgroup;
    # enddef;
    
    
    
  # Définition de nouveau symboles de lignes


    # Line symbol for strata for cross sections (u:strata). It works exactly as line section
    #     symbol but you should use -clip off option:
    # Symbole de ligne pour dessiner des strates (u:strata). 
    #     Cela fonctionne exactement comme les autres sections de ligne
    #     mais vous devrez rajouter l'option -clip off:
    def l_u_strata (expr P) =
      T:=identity;
      path Q; Q = punked P;
      for t = 0 upto length P - 1:
        pair zz[];
        zz1 := point t of P;
        zz2 := point t+1 of P;
        zz3 := postcontrol t of P;
        zz4 := precontrol t+1 of P;
        linecap:=0;
        if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or (length(zz4-2/3[zz1,zz2]) > 0.1pt):
          zz5 = whatever[zz1,zz2];
          (zz3-zz5) = whatever * (zz1-zz2) rotated 90;
          pickup pencircle scaled 1 mm;
          draw zz1--zz5 dashed evenly;
          pickup PenA;
          draw zz1--zz5 withcolor background;
          zz6 = whatever[zz1,zz2];
          (zz4-zz6) = whatever * (zz1-zz2) rotated 90;
          pickup pencircle scaled 1 mm;
          draw zz2--zz6 dashed evenly;
          pickup PenA;
          draw zz2--zz6 withcolor background;
        else:
          pickup pencircle scaled 1 mm;
          draw zz1--zz2 dashed evenly;
          pickup PenA;
          draw zz1--zz2 withcolor background;
        fi;
      endfor;
    enddef;


    # Line symbol for Coupoles (u:coupole). It works exactly as line section
    # Symbole de ligne pour dessiner des coupoles de plafond. 
    #     Fonctionne comme les autres lignes
    def l_u_coupole (expr P) = 
      T:=identity;
      cas := 0;                            % cursor to step along path
      dlzka := arclength P;
      mojkrok:=adjust_step(dlzka, 0.25u);  % symbol length nudged to be multiple of path length
      q:= (0.10u,0.16u) -- (0.13u,0.17u);         % dot
   
      pickup PenC;  %2nd thinnest pen
      forever:
        t := arctime cas of P;
        thdraw q rotated angle(thdir(P,t)) shifted (point t of P ); % draw dots
        cas := cas + mojkrok;
        exitif cas > dlzka + (mojkrok / 3); % for rounding errors
      endfor;
      pickup PenC;   %2nd thickest pen
      thdraw P;      %continuous line
    enddef;


    # Line symbol for fault. 
    #     It works exactly as line section symbol but you should use -clip off option:
    # Symbole de ligne pour dessiner des failles (u:fault). 
    #     Cela fonctionne exactement comme les autres sections de ligne
    #     mais vous devrez rajouter l'option -clip off:
    def l_u_fault (expr P) =
      T:=identity;
      path Q; Q = punked P;
      pickup PenA;
      for t = 0 upto length P - 1:
        pair zz[];
        zz1 := point t of P;
        zz2 := point t+1 of P;
        zz3 := postcontrol t of P;
        zz4 := precontrol t+1 of P;
        if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or (length(zz4-2/3[zz1,zz2]) > 0.1pt):
          zz5 = whatever[zz1,zz2];
          (zz3-zz5) = whatever * (zz1-zz2) rotated 90;
          draw zz1--zz5 dashed evenly;
          zz6 = whatever[zz1,zz2];
          (zz4-zz6) = whatever * (zz1-zz2) rotated 90;
          draw zz2--zz6 dashed evenly;
        else:
          draw zz1--zz2 dashed evenly;
        fi;
      endfor;
    enddef;


    # Line symbol for the surface. 
    #     It works exactly as line section symbol but you should use -clip off option:
    # Symbole de ligne pour dessiner la surface (u:surf). 
    #     Cela fonctionne exactement comme les autres sections de ligne
    #     mais vous devrez rajouter l'option -clip off:
    def l_u_surf (expr P) =
      T:=identity;
      path Q; Q = punked P;
      pickup PenC;
      draw Q dashed evenly withcolor (0.5, 0, 0);  
    enddef;


    # To add a doline line (u:doline); Do not forget the option -clip off !
    # Symbole de ligne pour dessiner une ligne doline (u:doline). 
    #     Cela fonctionne exactement comme les autres sections de ligne
    #     mais vous devrez rajouter l'option -clip off:
    def l_u_doline (expr P) =
      T:=identity;
      laenge:= arclength P;
      symsize:=adjust_step(laenge,2u);
      triangle_width:=symsize/10;
      cur:=(symsize-triangle_width)/2;
      pickup PenC;
      forever:
        t1 := arctime (cur) of P;
         t  := arctime (cur + triangle_width/2) of P;
        t2 := arctime (cur + triangle_width) of P;
        thfill (subpath (t1,t2) of P) --
          ((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
          cycle;
        thdraw (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) --
          (point t1 of P) withcolor (0.5, 0, 0);
        cur := cur + symsize;
        exitif cur > laenge - (1*symsize/3); % for rounding errors
        t1:=arctime (cur) of P;
      endfor;
    enddef;


    # Defines the gradient as geologic dip
    # Définit le gradient comme pendage géologique
    def p_gradient_XA (expr P,R,S,A) =
      U:=(.15u, .4u);
      T:=identity aligned A rotated R scaled S shifted P;
      pickup PenC;
      thdraw (0u, 0u) -- (0u, .4u);
      thdraw (-.4u, 0u) -- (.4u, 0u);
    enddef;
    initsymbol ("p_gradient_XA");
    symbol-assign point gradient XA


    # Section to define the bat symbol (point, line, area)
    # Section pour définir le symbole Chauve souris utilisé en point, ligne ou aire
    path bat_path_x;
    bat_path_x := (160.43589,619.76148)
    .. controls (200.83034,598.56215) and (225.01974,599.82632) .. (242.33709,601.15842)
    .. controls (250.91988,585.02142) and (280.12279,545.7622) .. (328.92385,566.52372)
    .. controls (343.18917,529.89929) and (387.77695,513.04018) .. (453.54702,518.36185)
    .. controls (456.6654,525.97557) and (466.09064,533.43257) .. (471.27843,523.05007)
    .. controls (463.85291,520.67657) and (466.71891,517.42483) .. (471.63814,522.23522)
    .. controls (472.87859,519.83044) and (472.11254,517.25674) .. (467.00984,516.24193)
    .. controls (498.08181,494.38071) and (518.37927,488.7935) .. (554.08261,484.34703)
    .. controls (536.23968,468.87122) and (526.7451,451.32142) .. (536.0878,433.78585)
    .. controls (539.04313,428.23891) and (549.65293,437.81051) .. (550.08905,431.99134)
    .. controls (543.35122,428.68782) and (547.16851,429.31755) .. (550.93619,430.90592)
    .. controls (555.01514,419.20795) and (542.29889,420.82043) .. (539.21019,422.32967)
    .. controls (526.80565,412.03922) and (538.14174,362.22955) .. (562.04206,325.41289)
    .. controls (560.70416,305.4475) and (552.94665,275.48765) .. (596.42383,240.15823)
    .. controls (586.13796,214.86512) and (584.21841,176.344) .. (618.88684,158.99293)
    .. controls (600.38363,161.42082) and (571.90452,163.00167) .. (555.87287,173.29962)
    .. controls (533.80922,180.31406) and (511.7587,189.77279) .. (494.76462,217.75852)
    .. controls (469.02274,260.15007) and (465.60841,280.08537) .. (466.27659,287.73284)
    .. controls (467.27295,299.13663) and (456.20597,295.4343) .. (455.42733,284.84646)
    .. controls (447.034,297.47822) and (465.71846,292.96944) .. (457.40227,311.17742)
    .. controls (451.51715,333.88534) and (454.55183,344.68208) .. (455.22274,365.27634)
    .. controls (445.59186,380.66207) and (438.52169,394.98144) .. (432.56329,406.97544)
    .. controls (421.27321,411.75599) and (411.86904,413.85884) .. (403.92838,423.33244)
    .. controls (391.19793,418.79449) and (380.875,414.46152) .. (373.6673,409.41976)
    .. controls (365.11095,413.84661) and (372.76761,437.1554) .. (372.88328,437.30963)
    -- (360.72573,447.88215)
    .. controls (360.72573,447.88215) and (348.36583,439.38367) .. (342.32921,440.26049)
    .. controls (340.52016,451.25937) and (343.58923,463.9528) .. (354.67087,475.2679)
    .. controls (341.63825,482.57642) and (339.10347,494.24676) .. (313.80723,490.57484)
    .. controls (304.61922,489.24114) and (282.31298,490.61764) .. (258.32359,496.84657)
    .. controls (246.18809,499.99759) and (248.48311,482.8706) .. (236.36849,493.22467)
    .. controls (239.32461,491.85429) and (242.55704,492.01948) .. (245.59044,495.64662)
    .. controls (248.83726,499.52895) and (249.4495,502.08244) .. (244.59097,503.87878)
    .. controls (221.93401,514.80409) and (190.83965,541.85436) .. (178.69512,574.11392)
    .. controls (176.80431,577.00681) and (162.4873,600.33708) .. cycle;
    path bat_path_bb;
    bat_path_bb = bbox bat_path_x;
    path bat_path;
    bat_path = bat_path_x shifted (-(llcorner bat_path_bb) - (urcorner bat_path_bb - llcorner bat_path_bb) / 2.0) scaled (1u / ((xpart urcorner bat_path_bb) - (xpart llcorner bat_path_bb))) rotated 210;

    # Pour définir le point chauve souris : u:bats
    def p_u_bats(expr pos, theta, sc, al) =
      T := identity shifted pos;
      thfill (bat_path scaled 1.5) withcolor black;
    enddef;

    # Idem pour la ligne
    def l_u_bats(expr P) =
      T:=identity;
      cas := 0;
      dlzka := arclength P;
      mojkrok:=adjust_step(dlzka, 1.0u);
      pickup PenD;
      forever:
        t := arctime cas of P;
        thfill bat_path scaled 0.5 shifted (point t of P) withcolor black;
        cas := cas + mojkrok;
        exitif cas > dlzka + (mojkrok / 3); % for rounding errors
      endfor;
    enddef;

    # Et pour l'aire
    % bat pattern
    beginpattern(pattern_bat);
      fill bat_path withcolor black;
    endpattern;

    % bat area symbol
    def a_u_bats (expr Path) =
      T:=identity;
      thclean Path;
      thfill Path withpattern pattern_bat;
    enddef;

  
    # Ces symbols seront inclus dans la légende. Pour modifier la façon dont ils
    #     sont dessinés, juste, définissez la macro appropriée.
    #     Son nom doit être le nom de la macro symbol approprié avec le suffixe 
    #     <code>_legend</code>.
    def l_u_bats_legend =
      l_u_bats(((.2,.2) -- (.8,.8)) inscale)
    enddef;


    # Definition of a stalagmite boss symbol
    # Définition du point stalagmite boss
    def p_u_boss (expr pos,theta,sc,al)=
      T:=identity aligned al rotated theta scaled sc shifted pos;
      pickup PenD;
      p := (0.08u,0.25u)..(0,0.29u)..(-0.08u,0.25u);
      q := (0.16u,0.5u)..(0u,0.58u)..(-0.16u,0.5u);
      for i=0 upto 9:
        # braun color
        thdraw p rotated 36i withcolor (100, 0.6, 0.2);
        thdraw q rotated 36i withcolor (100, 0.6, 0.2);
        % black color
        %thdraw p rotated 36i;
        %thdraw q rotated 36i;
      endfor
      p := fullcircle scaled 0.15u;
      thdraw p withcolor (100, 0.6, 0.2);
      % black color
      %thdraw p withcolor;
    enddef;


    # Definition of a shell limestone symbol
    # Définition du point coquille fossile
    def p_u_shell (expr pos,theta,sc,al)=
      T:=identity shifted pos;
      pickup PenB;
      numeric turns, radius;
      path ss, cesta;
      pair za, zb;
      turns = 1.55;
      radius = .3u;
      za = ( xpart(origin)+0, ypart(origin)+.1u ) rotated 370 turns;
      zb = ( xpart(origin)+.3u, ypart(origin)+0 ) rotated 360 turns;
      cesta := za--zb;
      ss := (origin for t=1 upto 360 turns: -- dir t scaled t endfor) scaled (radius/turns/360);
      thdraw ss withcolor (0.3);
      thdraw (cesta cutbefore ss) withcolor (0.6);
    enddef;
    initsymbol ("p_u_shell");

    
    # Define Danger symbol
    # Définition du point Danger
    def p_u_danger (expr P,R,S,A)=
      T:=identity aligned A rotated R scaled S shifted P;
      thfill (0,-u)--(u,0)--(0,u)--(0,.9u)--(.9u,0)--(0,-.9u)--cycle;
        thfill (0,-u)--(-u,0)--(0,u)--(0,.9u)--(-.9u,0)--(0,-.9u)--cycle;
      thfill (.1u,-.45u)..(0,-.35u)..(-.1u,-.45u)..(0,-.55u)..cycle;
      thfill (0,-.2u)..(.1u,-.1u)--(.2u,.4u)..(0,.6u)..(-.2u,.4u)--(-.1u,-.1u)..cycle;
    enddef;
    #initsymbol("p_entrance_MY");
    #let p_entrance = p_entrance_MY;
    

    # Define dive line (u:ariane) in thin red
    # Définition de la ligne file d'Ariane en rouge fin
    def l_u_ariane (expr Path) =
      T:=identity;
      pickup PenD;
      draw Path withcolor (100, 0, 0);
    enddef;

          
    # Definition of plankwalk
    # Définition d'une ligne de main courante
    def l_u_plankwalk  (expr P) = T:=identity;
      # by Dave Clucas
        cas := 0;
        dlzka := arclength P;
        mojrok := adjust_step(dlzka, 0.5u);
        pickup PenD;
      forever:
        t := arctime cas of P;
        thdraw ((point t of P) + 0.5 * u * unitvector(thdir(P,t) rotated 90)) --
        ((point t of P) - 0.5 * u * unitvector(thdir(P,t) rotated 90) );
        cas := cas + mojrok;
        exitif cas > dlzka + (mojrok/3);  % for rounding errors
      endfor;
      pickup PenC;
      %thdraw P; 
      %draw path withcolor (0.5, 0 ,0)
    enddef;

    
    # Definition of a line rail
    # Définition d'une ligne rail
    def l_u_rail (expr P) = 
      # by Andrew Aktinson
      T:=identity;
      cas := 0;
      dlzka := arclength P;
      mojkrok:=adjust_step(dlzka, 0.8u);
      pickup PenC;
      forever:
        t0 := arctime (cas) of P;
        t1 := arctime (cas + mojkrok*2/5) of P;
        t  := arctime (cas + mojkrok/2) of P;
        t4 := arctime (cas + mojkrok*3/5) of P;
        t5 := arctime (cas + mojkrok) of P;
        thdraw (subpath (t0,t1) of P);
        thdraw (subpath (t4,t5) of P);
        drawdot
        (point t of P);
        #mark_ (P,t,0.02u);
        #mark_ (P,t,-0.02u);
        #f := (P,t,0.2u);
        #draw f;
        cas := cas + mojkrok;
        exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
      endfor;
    enddef;


    # Change fig Flowstone, increase the number of arcs
    # Modifier le symbole flowstone en augmentant le nombr d'arc
    def l_flowstone (expr p) =
      #draw p withpen PenC withcolor (0.0, 0.5, 1.0);
      T:=identity;
      cas := 0;
      dlzka := arclength p;
      mojkrok:=adjust_step(dlzka, .3u);
      # povodne .7u
      pickup PenC;
      t1:=0;
      forever:
        t2 := arctime (cas + mojkrok) of p;
        thdraw (point t1 of p){dir (angle(thdir(p,t1)) + 60)} ..
            {dir (angle(thdir(p,t2)) - 60)}(point t2 of p);
        cas := cas + mojkrok;
        exitif cas > dlzka + (mojkrok / 3); % for rounding errors
        t1:=t2;
      endfor;
    enddef;


    # Point that represents a bird nest 
    # Point pour représenter un nid d'oiseau    
    def p_u_nid (expr pos,theta,sc,al)=
      U:=(.4u,.2u);
      T:=identity aligned al rotated theta scaled sc shifted pos;
      pickup PenC;
      #thdraw (-.4u,.2u){dir -70}..{dir 70}(.4u,.2u) withcolor (0.53, 0.26, 0.11);
      thdraw (-.2u,.1u){dir -70}..{dir 70}(.2u,.1u) withcolor (0.53, 0.26, 0.11);
    enddef;

    
    # Artificial anchor point (From a post by Evaristo Quiroga)
    # Point ancrage artificiel (From a post by Evaristo Quiroga)
    def p_u_anchor_artificial(expr pos,theta,sc,al) =
      T:=identity shifted pos;
      thdraw origin withpen pencircle scaled 0.25u withcolor (0.58, 0.44, 0.25);
    enddef;
    initsymbol ("p_u_anchor_artificial");


    # Natural anchor point (From a post by Evaristo Quiroga)
    # Point ancrage naturel (From a post by Evaristo Quiroga)
    def p_u_anchor_natural(expr pos,theta,sc,al) =
      U:=(.2u,.2u);
      T:=identity aligned al rotated theta scaled sc shifted pos;
      thfill (-.2u,-.2u)--(0,.2u)--(.2u,-.2u)--cycle withcolor (0.58, 0.44, 0.25); 
    enddef;
    initsymbol ("p_u_anchor_natural");


    # Deviation line (by Tarquin 2019)
    # Ligne pour dessiner une déviation (D'après Tarquin 2019)
    def l_u_deviation (expr P) =
      begingroup;
        save ellipse;
        T:=identity;
        pickup PenC;
        path ellipse;
         ellipse:=fullcircle xscaled (.5u) yscaled (.25u) shifted (point (length P) of P);
        thdraw P cutafter ellipse;
        draw ellipse;
      endgroup;
    enddef;
    initsymbol("l_u_deviation");
    def l_u_deviation_legend =
    l_u_deviation(((.1,.5)--(.8,.5)) inscale);
    enddef;


##### Pour que les cordes s'affichent sans points d'encrage. 
##### Ajouter les encrages avec des points
##### https://therion.speleo.sk/wiki/metapost#simplified_rope_lines

    % store the original clean_legend_box
    boolean l_rope_MY_inlegend;
    l_rope_MY_inlegend:=false;
    let l_rope_MY_legend_box = clean_legend_box;
    % redefine clean_legend_box to store the flag, then run the original
    def clean_legend_box =
      l_rope_MY_inlegend:=true;
      l_rope_MY_legend_box;
    enddef;

    def l_rope(expr P, show_anchors, show_rebelays)=
      T:=identity;
      pickup PenB;
      if l_rope_MY_inlegend:
      % drawing the legend - this gets run twice, since Therion draws two ropes, one for each parameter
      if show_rebelays:
        thdraw ((.35,.9) -- (.4,.85) -- (.4,.5) .. controls (.4,.4) and (.45,.4) .. (.5,.5) -- (.55,.45) -- (.55,.1)) inscale;
        thdraw ((.4,.85) -- (.45,.9)) inscale;
        thdraw ((.55,.45) -- (.6,.5)) inscale;
        thfill fullcircle scaled .15u shifted ((.35,.9) inscale);
        thfill fullcircle scaled .15u shifted ((.45,.9) inscale);
        thfill fullcircle scaled .15u shifted ((.5,.5) inscale);
        thfill fullcircle scaled .15u shifted ((.6,.5) inscale);
      fi;
      else:
      begingroup;
        save type;
        string type;
        if known ATTR_type:
        type:=ATTR_type;
        else:
        type:="primary";
        fi;
        if type = "secondary":
        thdraw P withcolor (0.7, 0.7, 0.7);
        else:
        thdraw P;
        fi;
      endgroup;
      fi;
    enddef;


    ##### Pour afficher les ancrages #####
    ##### https://therion.speleo.sk/wiki/metapost#p-hangers_that_face_the_right_way_and_other_anchor_designs

        % store the original clean_legend_box
    boolean p_anchor_MY_inlegend;
    p_anchor_MY_inlegend:=false;
    let p_anchor_MY_legend_box = clean_legend_box;
    % redefine clean_legend_box to store the flag, then run the original
    def clean_legend_box =
      p_anchor_MY_inlegend:=true;
      p_anchor_MY_legend_box;
    enddef;

    % a P-hanger, fixed point or natural circle
    def p_anchor_MY (expr P,R,S,A)=
      if p_anchor_MY_inlegend:
      % this is the legend - make sure the function works normally again
      p_anchor_MY_inlegend:=false;
      % draw a pretty legend - show all possibilities
      string ATTR_type;
      ATTR_type:="p";
      p_anchor_MY((.2,.57) inscale,270,1,(0,0));
      ATTR_type:="fixed";
      p_anchor_MY((.5,.5) inscale,0,1,(0,0));
      ATTR_type:="natural";
      p_anchor_MY((.7,.5) inscale,0,1,(0,0));
      else:
      begingroup;
        save type, facing;
        T:=identity aligned A rotated R scaled S shifted P;
        string type;
        if known ATTR_type:
        type:=ATTR_type;
        else:
        type:="auto";
        fi;
        if (type = "natural"):
        U:=(.2u,.2u);
        PenCThick:=(0.5u/10S); % thickness of PenC - pen thicknesses do not scale with S
        % fill with background colour, to remove any rope lines going through the point
        % this does not respect opacity, but there is no other way to remove lines from other objects
        % clipping currentpicture does not work, since ropes are always drawn last, then layered beneath point symbols
        thunfill fullcircle scaled (0.4u-PenCThick);
        thdraw fullcircle scaled (0.4u-PenCThick) withpen PenC;
        else:
        if (type = "fixed") or (ATTR__elevation and (type = "auto")):
          U:=(.2u,.2u);
          thfill fullcircle scaled 0.4u;
        else:
          if (R > 0) and (R < 180):
          facing:=-1
          else:
          facing:=1
          fi;
          if (type = "ropedp"):
          T:=identity shifted (facing*-0.25u,-0.25u) aligned A rotated R scaled S shifted P;
          fi;
          U:=(.25u,.4u);
          % thick part sticking out of the rock
          thdraw (0,0)--(0,.4u) withpen PenB;
          % thin part in the rock
          thdraw (0,-.2u)--(0,0) withpen PenC;
          % the loop should hang down the "page", based on the rotation
          % stubs to hold the semicircle
          thdraw (0,.1u)--(facing*.1u,.1u) withpen PenB;
          thdraw (0,.4u)--(facing*.1u,.4u) withpen PenB;
          % semicircle
          thdraw halfcircle scaled .3u rotated (facing*-90) shifted (facing*.1u,.25u) withpen PenB;
        fi;
        fi;
      endgroup;
      fi;
    enddef;
    initsymbol("p_anchor_MY");

  
    #     Point pour dessiner un spéléo qui grimpe ou escalade (D'après Juraj Halama, 2020)
    #    Le point correspond au centre du spéléo au niveau du harnais, qui doit donc être sur la corde
    picture u_man_c_pic;
      u_man_c_pic := image (
        draw (0cm, -0cm) -- (-8cm, 27cm) -- (-36cm, 55cm) -- (-50cm, 99cm) withpen pencircle scaled 16cm;
        draw (27cm, 48cm) -- (0, 64cm) -- (-29cm, 61cm) -- (-38cm, 102cm)  withpen pencircle scaled 16cm;
        draw (-65cm, 48cm) -- (-75cm, 75cm) -- (-53cm, 106cm) -- (0, 106cm) withpen pencircle scaled 14cm;
        draw (-44cm, 130cm) withpen pencircle scaled 27cm withcolor black;
      ) shifted (20cm, -67cm);

    def p_u_man_c (expr P, R, S, A) =
      U := (60cm, 85cm) scaled (0.01 / Scale);
      T:=identity aligned A rotated R scaled S shifted P;
      thdraw u_man_c_pic scaled (0.01 / Scale);
    enddef;
    initsymbol ("p_u_man_c");

    # The scale on the map and in the legend is matching just for 1:500...
    # L'échelle sur la carte et sur la légende correspond au 1:500...
    def p_u_man_c_legend =
      draw u_man_c_pic scaled (u / 175cm) shifted ((.5, .5) inscale);
    enddef;


    # Walking caver point (by Juraj Halama, 2020)
    #    Use "-align top" for proper alignment of the walking man when his point is on the groung.
    # Point pour dessiner un spéléo marchant (D'après Juraj Halama, 2020)
    #    Utiliser l'option "-align top" pour un alignement correct quand le point est au sol
    picture u_man_w_pic;
      u_man_w_pic := image (
        draw (0, 0) -- (7.5cm, 36cm) -- (0cm, 69cm) -- (9cm, 99cm) withpen pencircle scaled 16cm;
        draw (42cm, 9cm) -- (37.5cm, 42cm) -- (13.5cm, 69cm) -- (30cm, 102cm) withpen pencircle scaled 16cm;
        draw (21.5cm, 100.5cm) -- (6.6cm, 69cm) withpen pencircle scaled 16cm;
        draw (-24cm, 75cm) -- (-13.5cm, 102cm) -- (9cm, 112.5cm) -- (30cm, 108cm) -- (51cm, 87cm) -- (75cm, 93cm) withpen pencircle scaled 14cm;
        draw (30cm, 132cm) withpen pencircle scaled 27cm withcolor black;
      ) shifted (-20cm, -70cm);

    def p_u_man_w (expr P, R, S, A) =
      U := (60cm, 80cm) scaled (0.01 / Scale);
      T:=identity aligned A rotated R scaled S shifted P;
      thdraw u_man_w_pic scaled (0.01 / Scale);
    enddef;
    initsymbol ("p_u_man_w");

    # The scale on the map and in the legend is matching just for 1:500...
    # L'échelle sur la carte et sur la légende correspond au 1:500...
    def p_u_man_w_legend =
      draw u_man_w_pic scaled (u / 175cm) shifted ((.5, .5) inscale);
    enddef;


    symbol-color line map-connection [69 69 69]  # gris acier (175, 175, 175)
    

    # Aire pour matérialiser le départ d'une galerie
    #     A adapter en fonction de la couleur de vos galeries
    def a_u_galerie(expr P) =
      T:=identity;
      ## jaune chamois (208, 192, 122)
      ##thfill P withcolor (0.82,0.75,0.48) withtransparency 0.5;
      thfill P withcolor (0.82,0.75,0.48) withalpha 0.5;

      ## Grey
      ##thfill P withcolor (0.73,0.72,0.75) withtransparency 0.5;
      #thfill P withcolor (0.73,0.72,0.75) withalpha 0.5;

      ## Jaune queue de vache (168, 152, 116)
      ##thfill P withcolor (0.66,0.60,0.45) withtransparency 0.5;
      #thfill P withcolor (0.66,0.60,0.45) withalpha 0.5;

      ## gris argile (239, 239, 239)
      ##thfill P withcolor (0.937,0.937,0.937) withtransparency 0.5;
      #thfill P withcolor (0.937,0;937,0.937) withalpha 0.5;
    enddef;
    
    
    # Make unsurveyed wall lines light-weight and dashed
    # Rendre les parois non topographiées plus légères et en pointillés
    #Bruce Mutton 2010.06.20 for Therion 5.3.9
    def l_wall_unsurveyed (expr P) = 
      T:=identity;
      pickup PenC;
      thdraw P dashed evenly scaled (0.5*optical_zoom);
    enddef;
    
    
    # thin grey cave splays, yellow duplicates and dashed approximate legs
    # Pour modifier la couleur du squelette en fonction du type de visées 
    #     (splays, normal, duplicates, approximate...)
    def l_survey_cave (expr P) =
      % always draws full centreline, rather than short stubs like default cave centrelines
      T:=identity;
      pickup PenC;
      if ATTR__shotflag_splay:
        drawoptions(withcolor(0.5,0.5,0.5) withpen PenD);
        thdraw P; %  grey & thin
        drawoptions();
      else: % not splay but may have either or both duplicate and approx flags set
        if ATTR__shotflag_duplicate: 
          drawoptions(withcolor (1,1,0)); % differentiate duplicate with colour yellow
        fi;
        if ATTR__shotflag_approx:
          thdraw P dashed evenly scaled optical_zoom;  % differentiate approx with dashed
        else:
          thdraw P;
        fi;  
        thdrawoptions();
      fi;
    enddef;

  endcode
  # Endcode for all the definition

endlayout

